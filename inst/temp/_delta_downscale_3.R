#' Compute a delta raster.
#'
#' This function generates a delta (difference) raster, computed as the difference between
#' model estimates (`x`) and some observations (`high_res_obs`). `x` is a 
#' \code{terra::SpatRaster} of the variable we want to downscale, and it 
#' can contain multiple time steps. `ref_time` sets the time slice for which
#' the delta should be computed. 
#' 
#' If `obs` has a higher
#' resolution than `x`, the latter is interpolated using a bilinear algorithm.
#' For areas that are present in some time slices, but not in the observations
#' (e.g. due to sea level change), the delta map is extended to cover the maximum
#' cumulative land mask (over all time steps) using idw.
#'
#' @param x a \code{terra::SpatRaster} for the variable of interest, with all
#' time steps of interest
#' @param ref_time the time of the slice that is used to compute the delta
#' @param obs the observations
#'
#' @export

delta_compute <- function(x, ref_time, obs) {
  ref_index <- which(time_bp(x)==ref_time)
  if(length(ref_index)!=1){
    stop("ref_time should be a time in x")
  }
  x_modern<-x[[ref_index]]
  if (terra::ext(obs)!=terra::ext(x_modern)){
    stop("x_modern and high_res_obs don't have the same extent")
  }
  # disaggregate the x_modern SpatRaster to the resolution of
  # the high res with "bilinear" interpolation
  x_modern_high<-disagg(x_modern, fact = terra::res( x_modern)/terra::res(obs),
         method="bilinear")
  # compute anomalies against the modern
  delta <- obs - x_modern_high
  # mask for maximum land extent
  max_land <- max(x,na.rm=TRUE)
  max_land <- disagg(max_land, fact = terra::res( x)/terra::res(obs),
                     method="near")
  delta_interp <- idw_interp(delta,max_land)
  return(delta_interp)
}


#' Downscale using the delta method
#'
#' The delta method computes the difference between an observed raster and the
#' equivalent predictions from a model for a given time step, and then applies
#' that difference (delta) to all other time steps. You will first need to 
#' create the delta raster with \code{pastclim::delta_compute}, and thus use it
#' as an argument for this function.
#' 
#' It is possible to also provide a high resoultion landmask to this function.
#' For cells which are not included in the original simulation (e.g. because
#' the landmask was discretised at lower resolution), an idw algorightm is used
#' to interpolate the missing values. 
#'
#' @param x a \code{terra::SpatRaster} for the variable of interest, with all
#' time steps of interest
#' @param delta_rast a \code{terra::SpatRaster} generated by 
#' \code{pastclim::delta_compute}
#' @param x_landmask_high a \code{terra::SpatRaster} with the same number of layers
#' as x. If left NULL, the original landmask of x is used.
#'
#' @export


delta_downscale <- function(x, delta_rast,  x_landmask_high=NULL) {
  # check that extent and resolutions are compatible
  if (terra::ext(delta_rast)!=terra::ext(x)){
    stop("x and delta_rast don't have the same extent")
  }
  
  # downscale x with bilinear
  x_high <- disagg(x, fact = terra::res( x)/terra::res(delta_rast),
                        method="bilinear")
  
  # apply the delta_rast to x
  x_high <- x_high + delta_rast
  
  ##TODO
  ## Now loop over each layer of x_high, and run idw_gap to match the high
  ## resolution mask
  
  if(!is.null(x_landmask_high)){
    #refine the landmask in x_high
#    browser()
    x_high <- mask(x_high,x_landmask_high)
    # fill in any gaps that resulted from this step with idw
    for (i in 1:terra::nlyr(x_high)){
      x_high[[i]] <- idw_interp(x_high[[i]],x_landmask_high[[i]])
    }
  }
  
  return(x_high)
}

#' Create a land mask
#'
#' Create a land mask for a given time step
#'
#' @param topo_rast a \code{terra::SpatRaster} with topography
#' @param time_bp the time of interest
#' @param sea_level sea level at the time of interest (if left to NULL, this is
#' computed using Spratt 2016)
#'
#' @keywords internal

make_land_mask <- function(topo_rast, time_bp, sea_level = NULL) {
  if (is.null(sea_level)){
    # get sea level from Spratt 2016
    sea_level_info <-read.table(system.file("extdata/sea_level_spratt2016.txt",
                                            package="pastclim"), header=TRUE)
    time_calkaBP <- -time_bp/1000
    ## TODO this is not safe, we should be getting the closest values
    ## or even better interpolate
    sea_level <- sea_level_info$SeaLev_longPC1[match(time_calkaBP, sea_level_info$age_calkaBP)]
  } else { # check that we have as many sea level estimates as times
    if (length(time_bp)!=length(sea_level)){
      stop ("time_bp and sea_level should have the same number of elements")
    }
  }
  land_mask <- NULL
  for (i in 1:length(time_bp)) {
    topography_bin<-topo_rast
    topography_bin[topography_bin>sea_level[i]]<-NA
    topography_bin[!is.na(topography_bin)]<-1
    sea_patches<-patches(topography_bin)
    modal_vector <- function(x) {
      ux <- unique(x)
      ux[which.max(tabulate(match(x, ux)))]
    }
    patch_to_get <- modal_vector(values(sea_patches))
    sea_patches[is.na(sea_patches)]<- -1
    sea_patches[sea_patches != patch_to_get] <- -1
    sea_patches[sea_patches>0]<- NA
    sea_patches <- -sea_patches
    names(sea_patches) <- "mask"
    if (is.null(land_mask)){
      land_mask<-sea_patches
    } else {
      add(land_mask)<-sea_patches
    }
  }
  terra::time(land_mask) <- (time_bp+1950)
  return(land_mask)
  
}

#' Create a binary mask
#'
#' Create a binary mask where NAs are 0 and values are 1
#'
#' @param x a \code{terra::SpatRaster}
#'
#' @keywords internal

make_binary_mask <- function (x){
  x[!is.na(x)]<-1
  x[is.na(x)]<-0
  return(x)
}

#' Interpolate x to match mask y
#'
#' Fill in x to match cells in y, using iwd interpolation
#'
#' @param x the \code{terra::SpatRaster} of the variable of interest
#' @param y the \code{terra::SpatRaster} the reference mask defining which
#' cells should have values
#' 
#' @keywords internal

idw_interp <- function(x, y, ...){
  # first mask x with y (i.e. remove parts of y not found in the mask y)
  x<-terra::mask(x,y)
  x_bin <- make_binary_mask(x)
  y_bin <- make_binary_mask(y)
  # delta gap (pixels for which we don't have a delta values)
  x_gap <- y_bin - x_bin
  x_gap[x_gap==0]<-NA
  x_df <- terra::as.data.frame(x,xy=TRUE,na.rm=TRUE)
  x_gap_df <- terra::as.data.frame(x_gap, xy=TRUE, na.rm=TRUE)
  # if there is not gap between the values and the mask, just return the values
  if (nrow(x_gap_df)==0){
    return(x)
  }
  names(x_df)[3] <-"this_var"
  names(x_gap_df)[3] <-"this_var"
  # interpolate those gaps with idw (time consuming...)
  # add ... to the function to be able to take additional params to gstat
  idw_obj <- gstat::gstat(formula = this_var~1, locations = ~x+y, data = x_df, nmax=7,
                          set=list(idp = .5), ...)
  idw_pred <- predict(idw_obj, newdata = x_gap_df)[,-4] # remove the last column
  x_gap_vals <- terra::rast(idw_pred,type="xyz",crs=crs(x))
  x_gap_vals <- terra::extend(x_gap_vals, x)
  # now extend x to include the x_gap_vals
  x_extended <- sum(x,x_gap_vals,na.rm=TRUE)
  return(x_extended)
}
