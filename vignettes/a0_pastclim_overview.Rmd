---
title: "pastclim overview"
# output: rmarkdown::pdf_document
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pastclim overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Install the library

You will need to install the library from Github. For this step, you will need to
use `devtools` (if you haven't done so already, install it from CRAN with `install.packages("devtools")`.
Once you have `devtools`, simply use:
```{r install, eval=FALSE}
devtools::install_github("EvolEcolGroup/pastclim")
```

There is a vignette with detailed step by step examples on how to use the library. You can
find it on the website for the package. Or, if needed, you can build it when installing
`pastclim` :
```{r install_vignette, eval=FALSE}
devtools::install_github("EvolEcolGroup/pastclim", build_vignettes = TRUE)
```
And read it directly in R with:
```{r vignette, eval=FALSE}
vignette("pastclim_overview", package = "pastclim")
```
Depending on the operating system you use, you might need additional packages to build
a vignette.

---

NOTE: `pastclim` relies on `terra` to process rasters. There is a known bug in
`terra` that leads to the occasional message: 
```
"Error in x$.self$finalize() : attempt to apply non-function"
```

being reported. This is an error related to garbage collection, which does not 
affect the script being correctly executed, so it can be ignored. More discussion
of this issue can be found on [stack**overflow**](https://stackoverflow.com/questions/61598340/why-does-rastertopoints-generate-an-error-on-first-call-but-not-second)


# Download the data
You will need to download climatic reconstructions before being able to do any
work with `pastclim`. Currently the library contains two datasets: 
*Beyer2020* which covers the last 120k years; and, for project that go further back in time, *Krapp2021* which goes back to 800kya. For these two datasets, there are functions that help you download the data
and choose the variables. It is possible to add additional, custom datasets, but
you will need some familiarity with handling `netcdf` files (see the vignette on 
'custom dataset').

Datasets will stored in the package data path, which can be obtained with:

```{r}
library(pastclim)
get_data_path()
```

If you prefer using a custom path (e.g. in "~/my_reconstructions"), it can be set with:

```{r eval=FALSE}
set_data_path(path_to_nc = "~/my_reconstructions")
```

`pastclim` will remember this new path in the future, even after closing and restarting
R.

The package includes a small dataset, *Example*, that we will use in this vignette but is not suitable for running analyses;
the real datasets are large (from 100s of Mb to a few Gb), and you will need to specify
what you want to download (see below).

Let us start by inspecting the *Example* dataset. We can get a list of variables
available for this dataset with:

```{r}
get_vars_for_dataset(dataset = "Example")
```

and the available time steps available can be obtained with:

```{r}
get_time_steps(dataset = "Example")
```

For *Beyer2020* and *Krapp2021*, you can get a list
of available variables for each dataset with:
```{r}
get_vars_for_dataset(dataset = "Beyer2020")
```

and 

```{r}
get_vars_for_dataset(dataset = "Krapp2021")
```

You will not be able to get the available time steps until you download the data. `pastclim` offers an interface
to download the necessary files into your data path. 

To inspect which datasets and variables have already been downloaded in the data path,
we can use:
```{r}
get_downloaded_datasets()
```

Let's now download *bio01* and *bio05* for the *Beyer2020* dataset (this operation might take several minutes, as the datasets are large; `R` will pause until
the download is complete):

```{r eval=FALSE}
download_dataset(dataset = "Beyer2020", bio_variables = c("bio01", "bio05"))
```

Note that multiple variables are packed together into a single file, so the command might list more variables than the ones that we downloaded originally.

We have found that on some installations of R (mostly on macOS), the default data path
chosen by R can lead to an error when downloading datasets (this is due to incorrect 
writing permission for 
that path). If you get an error when downloading data stating "Failed to open file ...",
set the path with `set_data_path` to a directory in
your user area, and the error should disappear when you issue again the `download_dataset` command.

# Get climate for locations

Often we want to get the climate for specific locations. We can do so by using
the function `location_slice`. With this function, we will get slices of climate
for the times relevant to the locations of interest.

Let us create some fictitious locations:

```{r}
locations <- data.frame(
  longitude = c(0, 90, -120, -9), latitude = c(20, 45, 60, 37),
  time_bp = c(0, -9753, -18738, -11849)
)
locations
```

And extract their climatic conditions for *bio01* and *bio12*:
```{r}
location_slice(
  x = locations[, c("longitude", "latitude")],
  time_bp = locations$time_bp, bio_variables = c("bio01", "bio12"),
  dataset = "Example", nn_interpol = FALSE
)
```
`pastclim` finds the closest time steps (slices) available for a given date, and outputs
the slice used in column `time_bp_slice` (the *Example* dataset that we use in this vignette has a temporal resolution of only 5k years).

Note that the last two locations, for the appropriate time steps, are not available (either under water or ice), and so `pastclim` does not return a climate reconstruction. In some instances, this is due to the discretisation of space in the raster. We can interpolate climate among the nearest neighbours, thus using climate reconstructions for neighbouring pixels if the location is just off one or more land pixels:
```{r}
location_slice(
  x = locations[, c("longitude", "latitude")],
  time_bp = locations$time_bp, bio_variables = c("bio01", "bio12"),
  dataset = "Example", nn_interpol = TRUE)
```
In this case, the last location is indeed just off the coast, and so we can reconstruct some appropriate climate by interpolating. Note that `nn_interpol = TRUE` is the default for this function.

Sometimes, we want to get a time series of climatic reconstructions, thus allowing us to
see how climate changed over time:
```{r}
locations_ts <- location_series(
  x = locations[, c("longitude", "latitude")],
  bio_variables = c("bio01", "bio12"),
  dataset = "Example")
```

The resulting dataframe can be subsetted to get the time series for each location
(the small *Example* dataset only contains 5 time slices):
```{r}
subset(locations_ts, id == 1)
```
Also note that for some locations, climate can be available only for certain time steps, depending on sea level and ice sheet extent. This is the case for location 3: 
```{r}
subset(locations_ts, id == 3)
```

# Get climate for a region

Instead of focussing on specific locations, we might want to look at a whole region.
For a given time step, we can extract a slice of climate with

```{r}
climate_20k <- region_slice(
  time_bp = -20000,
  bio_variables = c("bio01", "bio10", "bio12"),
  dataset = "Example"
)
```

This returns a raster (technically a `spatRaster` object as defined in the `terra`
library, meaning that we can perform all standard `terra` raster operations
on this object). To interact with `spatRaster` objects, it is best to load the
`terra` library (otherwise you might get errors as the correct method is not found, e.g. 
when plotting); we can then get a summary of this object:
```{r}
library(terra)
climate_20k
```

and plot these three variables (the layers of the raster):
```{r, fig.width=6, fig.height=5}
terra::plot(climate_20k, main = names(climate_20k))
```

It is possible to also load a time series of rasters with the function `region_series`. In this case, the function returns a `spatRasterDataset`, with each variable as a sub-dataset:

```{r}
climate_region <- region_series(
  time_bp = list(min = -15000, max = 0), 
  bio_variables = c("bio01", "bio10", "bio12"),
  dataset = "Example")
climate_region
```

Each of these sub-dataset is a `spatRaster`, with time steps as layers:

```{r}
climate_region$bio01
```

We can then plot the time series of a given variable:
```{r, fig.width=6, fig.height=5}
terra::plot(climate_region$bio01)
```

To plot all climate variables for a given time step, we can slice the time series:
```{r, fig.width=6, fig.height=5}
slice_10k <- slice_region_series(climate_region, time_bp = -10000)
terra::plot(slice_10k, main = names(slice_10k))
```

Instead of giving a minimum and maximum time step, you can also provide
specific time steps to `region_series`. Note that `pastclim` has a function to get a vector
of the time steps for a given MIS in a dataset. For example, for MIS 1, we get:
```{r}
mis1_steps <- get_mis_time_steps(mis = 1, dataset = "Example")
mis1_steps
```
Which we can then use:
```{r}
climate_mis1 <- region_series(
  time_bp = mis1_steps, 
  bio_variables = c("bio01", "bio10", "bio12"),
  dataset = "Example"
)
climate_mis1
```

# Cropping

Often we want to focus a given region. There are a number of preset rectangular extents in 
`pastclim`:
```{r}
names(region_extent)
```

We can get the corners of the European extent:
```{r}
region_extent$Europe
```

And then we can extract climate only for Europe by setting `ext` in `region_slice`:

```{r, fig.width=6, fig.height=5}
europe_climate_20k <- region_slice(
  time_bp = -20000,
  bio_variables = c("bio01", "bio10", "bio12"),
  dataset = "Example",
  ext = region_extent$Europe
)
terra::plot(europe_climate_20k,
            main = names(europe_climate_20k))
```

As we can see in the plot, cutting Europe using a rectangular shape keeps a portion of Northern Africa in the map. `pastclim` includes a number of pre-generated masks for the main continental masses, stored in the dataset `region_outline` in an `sf::sfc` object. We can get a list with:

```{r}
names(region_outline)
```
We can then use the function `crop` within `region_slice` to only keep the area within the desired outline.

```{r, fig.width=6, fig.height=5}
europe_climate_20k <- region_slice(
  time_bp = -20000,
  c("bio01", "bio10", "bio12"),
  dataset = "Example",
  crop = region_outline$Europe
)
terra::plot(europe_climate_20k,
            main = names(europe_climate_20k))
```

We can combine multiple regions together. For example, we can cropt to Afircan and Eurasia by unioning the two indiviudal outlines:

```{r, fig.width=6, fig.height=5}
library(sf)
afr_eurasia <- sf::st_union(region_outline$Africa, region_outline$Eurasia)
climate_20k_afr_eurasia <- region_slice(
  time_bp = -20000,
  bio_variables  = c("bio01", "bio10", "bio12"),
  dataset = "Example",
  crop = afr_eurasia)
terra::plot(climate_20k_afr_eurasia,
            main = names(climate_20k_afr_eurasia))
```

Note that outlines that cross the antimeridian are split into multiple polygons (so that they can be used without projecting the rasters). For Eurasia, we have the eastern end of Siberia on the left hand side of the plot. `continent_outlines_union` provides the same outlines as single polygons (in case you want to use a projection). 

You can also use your own custom outline (i.e. a polygon, coded as a `terra::vect` 
object) as a mask to limit 
the area covered by the raster. Note that you need to 
reuse the first vertex as the last vertex, to close the polygon:

```{r, fig.width=6, fig.height=5}
custom_vec <- terra::vect("POLYGON ((0 70, 25 70, 50 80, 170 80, 170 10,
                              119 2.4, 119 0.8, 116 -7.6, 114 -12, 100 -40,
                              -25 -40, -25 64, 0 70))")
climate_20k_custom <- region_slice(
  time_bp = -20000,
  bio_variables = c("bio01", "bio10", "bio12"),
  dataset = "Example",
  crop = custom_vec)
terra::plot(climate_20k_custom, 
            main = names(climate_20k_custom))
```

`region_series` takes the same `ext` and `crop` options as `region_slice` to limit
the extent of the climatic reconstructions.

# Working with biomes and ice sheets

The Beyer2020 and Krapp2021 datasets include a categorical variable detailing the extension of biomes.

```{r}
get_biome_classes("Example")
```
If we need to plot the extent of a specific biome, for example the desert, we first extract the variable and then subset it to just the class we are interested in using its ID (21, in this case):

```{r, fig.width=6, fig.height=5}
climate_20k <- region_slice(
  time_bp = -20000,
  bio_variables = c("bio01", "bio10", "biome"),
  dataset = "Example"
)
climate_20k$desert <- climate_20k$biome
climate_20k$desert[climate_20k$desert != 21] <- FALSE
climate_20k$desert[climate_20k$desert == 21] <- TRUE
terra::plot(climate_20k, main = names(climate_20k))
```

The climate reconstructions do not show areas under permanent ice. Ice sheets are stored as class 28 in the "biome" variable:

To plot it, we use functions designed to get ice and land masks.
```{r, fig.width=6, fig.height=5}
climate_20k <- region_slice(
  time_bp = -20000,
  bio_variables = c("bio01", "bio10"),
  dataset = "Example"
)
climate_20k$ice_mask <- get_ice_mask(-20000, dataset = "Example")
climate_20k$land_mask <- get_land_mask(-20000, dataset = "Example")
terra::plot(climate_20k, main = names(climate_20k))
```

# Set the samples within the background

In many studies, we want to set the environmental conditions at a given set of
location within the background for that time period. Let us start by
visualising the background for the time step of interest with a PCA:

```{r, fig.width=4, fig.height=4}
bio_vars <- c("bio01", "bio10", "bio12")
climate_10k <- region_slice(-10000,
  bio_variables = bio_vars,
  dataset = "Example"
)
climate_values_10k <- df_from_region_slice(climate_10k)
climate_10k_pca <- prcomp(climate_values_10k[, bio_vars], 
                          scale = TRUE, center = TRUE)
plot(climate_10k_pca$x[, 2] ~ climate_10k_pca$x[, 1],
  pch = 20, col = "lightgray",
  xlab = "PC1", ylab = "PC2"
)
```

We can now get the climatic conditions for the locations at this time step and compute the PCA scores based on the axes we defined on the background:
```{r}
locations_10k <- data.frame(
  longitude = c(0, 90, 20, 5), latitude = c(20, 45, 50, 47),
  time_bp = c(-9932, -9753, -10084, -10249)
)
climate_loc_10k <- location_slice(
  x = locations_10k[, c("longitude", "latitude")],
  time_bp = locations_10k$time_bp, bio_variables = bio_vars,
  dataset = "Example"
)
locations_10k_pca_scores <- predict(climate_10k_pca, newdata = climate_loc_10k[, bio_vars])
```

And now we can plot the points on top of the background
```{r, fig.width=4, fig.height=4}
plot(climate_10k_pca$x[, 2] ~ climate_10k_pca$x[, 1],
  pch = 20, col = "lightgray",
  xlab = "PC1", ylab = "PC2"
)
points(locations_10k_pca_scores, pch = 20, col = "red")
```
If we want to pool the background from multiple time steps, we can simple use
`region_series` to get a series, adn then transform it into a data frame with
`df_from_region_series`.

# Random sampling of background

NOTE: there is a bug in terra 1.6.17 that prevents this section from 
working; you will get a "negative probability" error when sampling 
if you use that version.

For a number of species distribution models, rather than using the complete
background, we need to subsample background points to our presences. 
If we are interested in a single time step, we can simply generate the 
raster for the time slice of interest, and use `sample_region_slice`:

```{r}
climate_20k <- region_slice(
  time_bp = -20000,
  bio_variables = c("bio01", "bio10"),
  dataset = "Example"
)
this_sample <- sample_region_slice(climate_20k, size = 100)
head(this_sample)
```

We can also sample the background for multiple time steps (e.g. if we want to 
match the background to the number of samples based on their radiocarbon dates).
So, for example, if
we wanted 3 samples from 20k years ago and 5 samples from 10k years ago:

```{r}
climate_ts <- region_series(
  time_bp = c(-20000,-10000),
  bio_variables = c("bio01", "bio10", "bio12"),
  dataset = "Example",
  ext = terra::ext(region_extent$Europe)
)
sampled_climate <- sample_region_series(climate_ts, size = c(3,5))
sampled_climate

```