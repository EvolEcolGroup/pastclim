---
title: "pastclim overview"
output: rmarkdown::pdf_document
# output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pastclim overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Install the library

You will need to install the library from Github. For this step, you will need to
use `devtools` (if you haven't done so already, install it from CRAN with `install.packages("devtools")`.
Once you have `devtools`, simply use:
```{r install, eval=FALSE}
devtools::install_github("EvolEcolGroup/pastclim")
```

There is a vignette with detailed step by step examples on how to use the library. You can
find it on the website for the package. Or, if when can build it when installing
`pastclim` :
```{r install_vignette, eval=FALSE}
devtools::install_github("EvolEcolGroup/pastclim", build_vignettes = TRUE)
```
And read it directly in R with:
```{r vignette, eval=FALSE}
vignette("pastclim_overview", package = "pastclim")
```
Depending on the operating system you use, you might need additional packages to build
a vignette.
---

NOTE: `pastclim` relies on `terra` to process rasters. There is a known bug in
`terra` that leads to the occasional message: 
```
"Error in x$.self$finalize() : attempt to apply non-function"
```

being reported. This is an error related to garbage collection, which does not 
affect the script being correctly executed, so it can be ignored. More discussion
of this issue can be found on [stack**overflow**](https://stackoverflow.com/questions/61598340/why-does-rastertopoints-generate-an-error-on-first-call-but-not-second)


# Download the data
You will need to download climatic reconstructions before being able to do any
work with `pastclim`. Currently the library contains two datasets: 
*Beyer2020* which covers the last 120k years; and, for project that go further back in time, *Krapp2021* which goes back to 800kya. For these two datasets, there are functions that help you download the data
and choose the variables. It is possible to add additional, custom datasets, but
you will need some familiarity with handling `netcdf` files (see the vignette on 
'Formatting data to use in pastclim').

Datasets will stored in the package data path, which can be obtained with:

```{r}
library(pastclim)
get_data_path()
```

If you prefer using a custom path (e.g. in "~/my_reconstructions"), it can be set with:

```{r eval=FALSE}
set_data_path(path_to_nc = "~/my_reconstructions")
```

`pastclim` will remember this new path in the future, even after closing and restarting
R.

The package includes a small dataset, *Example*, that we will use in this vignette;
the real datasets are large (from 100s of Mb to a few Gb), and you will need to specify
what you want to download (see below).

Let us start by inspecting the *Example* dataset. We can get a list of variables
available for this dataset with:

```{r}
get_vars_for_dataset(dataset = "Example")
```

and the available time steps available can be obtained with:

```{r}
get_time_steps(dataset = "Example")
```

For *Beyer2020* and *Krapp2021*, you can get a list
of available variables for each dataset with:
```{r}
get_vars_for_dataset(dataset = "Beyer2020")
```

and 

```{r}
get_vars_for_dataset(dataset = "Krapp2021")
```

You will not be able to get the available time steps until you download the data. `pastclim` offers an interface
to download the necessary files into your data path. 

To inspect which datasets and variables have already been downloaded in the data path,
we can use:
```{r}
get_downloaded_datasets()
```

Let's now download *bio01* and *bio05* for the *Beyer2020* dataset (this operation might take several minutes, as the datasets are large; `R` will pause until
the download is complete):

```{r eval=FALSE}
download_dataset(dataset = "Beyer2020", bio_variables = c("bio01", "bio05"))
```

Note that multiple variables are packed together into a single file, so the command might list more variables than the ones that we downloaded originally.

# Get climate for locations

Often we want to get the climate for specific locations. We can do so by using
the function `location_slice`. With this function, we will get slices of climate
for the times relevant to the locations of interest.

Let us create some fictitious locations:

```{r}
locations <- data.frame(
  longitude = c(0, 90, -120, -7), latitude = c(20, 45, 60, 37),
  time_bp = c(0, -9753, -18738, -11849)
)
locations
```

And extract their climatic conditions for *bio01* and *bio12*:
```{r}
location_slice(
  x = locations[, c("longitude", "latitude")],
  time_bp = locations$time_bp, bio_variables = c("bio01", "bio12"),
  dataset = "Example", nn_interpol = FALSE
)
```
`pastclim` finds the closest time steps (slices) available for a given date, and ouputs
the slice used in column `time_bp_slice` (the *Example* dataset that we use in this vignette has a temporal resolution of only 5k years).

Note that the last two locations, for the appropriate time steps, are not available (either under water or ice), and so `pastclim` does not return a climate reconstruction. In some instances, this is due to the discretisation of space in the raster. We can interpolate climate among the nearest neighbours, thus using climate reconstructions for neighbouring pixels if the location is just off one or more land pixels:
```{r}
location_slice(
  x = locations[, c("longitude", "latitude")],
  time_bp = locations$time_bp, bio_variables = c("bio01", "bio12"),
  dataset = "Example", nn_interpol = TRUE
)
```
In this case, the last location is indeed just off the coast, and so we can reconstruct some appropriate climate by interpolating. Note that `nn_interpol = TRUE` is the default for this function.

Sometimes, we want to get a time series of climatic reconstructions, thus allowing us to
see how climate changed over time:
```{r}
locations_ts <- location_series(
  x = locations[, c("longitude", "latitude")],
  bio_variables = c("bio01", "bio12"),
  dataset = "Example"
)
```

The resulting dataframe can be subsetted to get the time series for each location
(note that the small *Example* dataset only contains 5 time points):
```{r}
subset(locations_ts, id == 1)
```
Also note that the last two locations do not return information for all time steps. That's due to the change in sea level and ice sheet extent, and this function (as opposed to `climate_for_locations`) does not allow for interpolation.
```{r}
subset(locations_ts, id == 3)
```
```{r}
subset(locations_ts, id == 4)
```

# Get climate for a region

Instead of focussing on specific locations, we might want to look a whole region.
For a given time step, we can extract a slice of climate with

```{r}
climate_20k <- region_slice(
  time_bp = -20000,
  c("bio01", "bio10", "bio12"),
  dataset = "Example"
)
```

This returns a raster (technically a `spatRaster` object as defined in the `terra`
library, meaning that we can perform all standard `terra` raster operations
on this object). To interact with `spatRaster` objects, it is best to load the
`terra` library; we can then get a summary of this object:
```{r}
library(terra)
climate_20k
```

and plot these three variables (the layers of the raster):
```{r, fig.width=6, fig.height=5}
terra::plot(climate_20k, main = names(climate_20k))
```

Often we want to focus a given region. There are a number of preset extents in 
`pastclim`:
```{r}
region_extent
```

We can extract climate only for Europe; we need to pass an `terra::SpatExtent`
object to `region_slice`:

```{r, fig.width=6, fig.height=5}
europe_climate_20k <- region_slice(
  time_bp = -20000,
  c("bio01", "bio10", "bio12"),
  dataset = "Example",
  ext = terra::ext(region_extent$Europe)
)
terra::plot(europe_climate_20k,
            main = names(europe_climate_20k))
```

Alternatively, we can crop an already extracted raster:
```{r, fig.width=6, fig.height=5}
europe_climate_20k_alt <- terra::crop(climate_20k, terra::ext(region_extent$Europe))
terra::plot(europe_climate_20k_alt,
            main = names(europe_climate_20k_alt))
```

We might want to use a more complex shape (i.e. a polygon, as a `terra::vect` 
object) as a mask to limit 
the area covered by the raster. For example, we might want to focus the 3 
continents Africa, Europe and Asia, but exclude the Americas and Oceania. We
need to create a polygon with the appropriate vertices (note that you need to 
reuse the first vertex as the last vertex, to close the polygon).

```{r, fig.width=6, fig.height=5}
afr_eurasia_vec <- terra::vect("POLYGON ((0 70, 25 70, 50 80, 170 80, 170 10,
                              119 2.4, 119 0.8, 116 -7.6, 114 -12, 100 -40,
                              -25 -40, -25 64, 0 70))")
climate_20k_afr_eurasia <- region_slice(
  time_bp = -20000,
  c("bio01", "bio10", "bio12"),
  dataset = "Example",
  crop = afr_eurasia_vec)
terra::plot(climate_20k_afr_eurasia, 
            main = names(climate_20k_afr_eurasia))
```

`pastclim` includes a number of pre-generated masks for the main continental masses, stored in the dataset `continent_outlines` in an `sf` object. Note that outlines that cross the antimeridian are split into multiple polygons (so that they can be used without projecting the rasters). `continent_outlines_union` provides the same outlines as single polygons (in case you want to use a projection). We can build the outline for Africa and Eurasia by unioning the two individual outlines:
```{r}
library(sf)
africa_outline <- subset(region_outline, region_outline$name == "Africa")
eurasia_outline <- subset(region_outline, region_outline$name == "Eurasia")
afr_eurasia_vec <- terra::vect(sf::st_union(africa_outline, eurasia_outline))
climate_20k_afr_eurasia <- region_slice(
  time_bp = -20000,
  c("bio01", "bio10", "bio12"),
  dataset = "Example",
  crop = afr_eurasia_vec)
terra::plot(climate_20k_afr_eurasia,
            main = names(climate_20k_afr_eurasia))
```

Note that the Eurasian outline is intersected by the antimeridian, and so we have a small amount of data on the left hand side of the plot (corresponding to the eastern end of Siberia).

It is possible to also load a time series of rasters with the function `region_series`. In this case, the function returns a `spatRasterDataset`, with each variable as a sub-dataset:

```{r}
climate_region <- region_series(
  time_bp = list(min=-15000,max=0), c("bio01", "bio10", "bio12"),
  "Example"
)
climate_region
```

Each of these sub-dataset is a `spatRaster`, with time steps as layers:

```{r}
climate_region$bio01
```

We can then plot the time series of a given variable:
```{r}
terra::plot(climate_region$bio01)
```

To plot all climate variables for a given time step, we can slice the time series:
```{r}
slice_10k <- slice_region_series(climate_region, time_bp = -10000)
terra::plot(slice_10k, main = names(slice_10k))
```

`region_series` takes the same `ext` and `crop` options as `region_slice` to limit
the extent of the climatic reconstrutions.

# Working with biomes and ice sheets
The climate reconstructions do not show areas under permanent ice. Ice sheets are stored as class 28 in the "biome" variable:
```{r}
get_biome_classes("Example")
```

To plot it, we extract the biome and then subset it to just that class
```{r, fig.width=6, fig.height=5}
climate_20k <- region_slice(
  time_bp = -20000,
  bio_variables = c("bio01", "bio10", "biome"),
  dataset = "Example"
)
climate_20k$ice <- climate_20k$biome
climate_20k$ice[climate_20k$ice != 28] <- FALSE
climate_20k$ice[climate_20k$ice == 28] <- TRUE
terra::plot(climate_20k, main = names(climate_20k))
```

Or more simply, we use functions designed to get ice and land masks.
```{r, fig.width=6, fig.height=5}
climate_20k <- region_slice(
  time_bp = -20000,
  c("bio01", "bio10"),
  dataset = "Example"
)
climate_20k$ice_mask <- get_ice_mask(-20000, dataset = "Example")
climate_20k$land_mask <- get_land_mask(-20000, dataset = "Example")
terra::plot(climate_20k, main = names(climate_20k))
```

# Set the samples within the background

We can visualise the environment for this time step with a PCA:
```{r, fig.width=4, fig.height=4}
climate_10k <- region_slice(-10000,
  c("bio01", "bio10", "bio12"),
  dataset = "Example"
)
climate_values_10k <- values(climate_10k)
climate_values_10k <- climate_values_10k[!is.nan(climate_values_10k[, 1]), ]
climate_10k_pca <- prcomp(climate_values_10k, scale = TRUE, center = TRUE)
plot(climate_10k_pca$x[, 2] ~ climate_10k_pca$x[, 1],
  pch = 20, col = "lightgray",
  xlab = "PC1", ylab = "PC2"
)
```

We can now get the climate variables for the locations at this time step, compute the PCA scores and plots the locations on top of the background climate:
```{r, fig.width=4, fig.height=4}
locations_10k <- location_slice(
  x = locations[, c("longitude", "latitude")],
  time_bp = locations$time_bp, bio_variables = c("bio01", "bio12"),
  dataset = "Example"
)
locations_10k <- locations_10k[locations_10k$time_bp_slice == -10000, ]
locations_10k_climate <- location_slice(
  x = locations_10k[, c("longitude", "latitude")],
  time_bp = locations_10k$time_bp, bio_variables = c("bio01", "bio10", "bio12"),
  dataset = "Example"
)
locations_10k_pca_scores <- predict(climate_10k_pca, newdata = locations_10k_climate[, -c(1:4)])
plot(climate_10k_pca$x[, 2] ~ climate_10k_pca$x[, 1],
  pch = 20, col = "lightgray",
  xlab = "PC1", ylab = "PC2"
)
points(locations_10k_pca_scores, pch = 20, col = "red")
```

## Working with MIS
Sometimes we want to work with multiple time steps to represent a given MIS.
We can get a list of time steps available for a given mis with:
```{r}
mis_time_steps <- get_mis_time_steps(1, "Example")
mis_time_steps
```

And now cycle over those steps. First extract the climate into a list:
```{r}
mis_climate_list <- list()
for (this_step in mis_time_steps) {
  this_step_climate <-
    region_slice(
      time_bp = this_step,
      bio_variables = c("bio01", "bio10", "bio12"),
      dataset = "Example"
    )
  this_step_climate <- values(this_step_climate)
  this_step_climate <-
    this_step_climate[!is.nan(this_step_climate[, 1]), ]
  mis_climate_list[[as.character(this_step)]] <- this_step_climate
}
```

Then combine them into a single matrix:
```{r}
mis_climate <- do.call(rbind, mis_climate_list)
```

And finally plot it:
```{r, fig.width=4, fig.height=4}
mis_pca <- prcomp(mis_climate, scale = TRUE, center = TRUE)
plot(mis_pca$x[, 2] ~ mis_pca$x[, 1],
  pch = 20, col = "lightgray",
  xlab = "PC1", ylab = "PC2"
)
```


# Random sampling of background

For a number of species distribution models, we need to subsample background points to our presences. We can simply do that by generating the raster for the time slice of interest, and using the appropriate function from `terra`:

```{r}
climate_20k <- region_slice(
  time_bp = -20000,
  bio_variables = c("bio01", "bio10"),
  dataset = "Example"
)
this_sample <- terra::spatSample(climate_20k, 100,
  na.rm = TRUE,
  cells = TRUE, xy = TRUE
)
head(this_sample)
```

If we needed to get other variables for those coordinates, we could simply:
```{r}
additional_var <- location_slice(
  x = data.frame(longitude = this_sample$x, latitude = this_sample$y),
  time_bp = rep(-20000, nrow(this_sample)),
  bio_variables = c("bio12"),
  dataset = "Example"
)
head(additional_var)
```

Alternatively, we could use the cell number:
```{r}
additional_var <- location_slice(
  x = this_sample$cell,
  time_bp = rep(-20000, nrow(this_sample)),
  bio_variables = c("bio12"),
  dataset = "Example"
)
head(additional_var)
```
