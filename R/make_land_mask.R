#' Create a land mask
#'
#' Create a land mask for a given time step. The land mask is based on the simple
#' logic of moving the ocean up and down given the current relief profile (
#' topography+bathymetry, i.e. the elevation both above and below sea level).
#' Note that this approach ignores any rebound due to changing mass and distribution of
#' icesheets. The landmask will show internal lakes/seas as land, as their level
#' is unrelated to the general sea level. If you have specific reconstructions
#' of internal lakes (or want to simply reuse their current extents), you will
#' have to add them onto the masks generated by this function.
#'
#' @param relief_rast a \code{terra::SpatRaster} with relief
#' @param time_bp the time of interest
#' @param sea_level sea level at the time of interest (if left to NULL, this is
#' computed using Spratt 2016)
#' @returns a \code{terra::SpatRaster} of 0s (sea) and 1s (land), where the
#' layers are different times
#'
#' @keywords internal

make_land_mask <- function(relief_rast, time_bp, sea_level = NULL) {
  message("This function is still under development; do not use it for real analysis")
  if (is.null(sea_level)){
    # get sea level from Spratt 2016
    sea_level_info <- utils::read.table(system.file("extdata/sea_level_spratt2016.txt",
                                            package="pastclim"), header=TRUE)
    time_calkaBP <- -time_bp/1000
    ## TODO this is not safe, we should be getting the closest values
    ## or even better interpolate
    sea_level <- sea_level_info$SeaLev_longPC1[match(time_calkaBP, sea_level_info$age_calkaBP)]
  } else { # check that we have as many sea level estimates as times
    if (length(time_bp)!=length(sea_level)){
      stop ("time_bp and sea_level should have the same number of elements")
    }
  }
  land_mask <- NULL
  for (i in 1:length(time_bp)) {
    # create binary relief map for areas above and below the relevant sea level
    relief_bin<-relief_rast
    relief_bin[relief_bin>sea_level[i]]<-NA
    relief_bin[!is.na(relief_bin)]<-1
    sea_patches<-patches(relief_bin)
    modal_vector <- function(x) {
      ux <- unique(x)
      ux[which.max(tabulate(match(x, ux)))]
    }
    patch_to_get <- modal_vector(values(sea_patches))
    sea_patches[is.na(sea_patches)]<- -1
    sea_patches[sea_patches != patch_to_get] <- -1
    sea_patches[sea_patches>0]<- NA
    sea_patches <- -sea_patches
    names(sea_patches) <- "mask"
    if (is.null(land_mask)){
      land_mask<-sea_patches
    } else {
      add(land_mask)<-sea_patches
    }
  }
  # work around problem of old terra failing to set time units for negative values 
  # (fixed in dev in 1.6.49)
  if (utils::packageVersion("terra")<"1.6.49"){
    terra::time(land_mask, tstep="") <- (time_bp+1950)
  } else {
    terra::time(land_mask, tstep="years") <- (time_bp+1950)
  }
  return(land_mask)
  
}
