#' Downscale using the delta method
#'
#' The delta method computes the difference between an observed raster and the
#' equivalent predictions from a model for a given time step, and then applies
#' that difference (delta) to all other time steps. You will first need to 
#' create the delta raster with \code{pastclim::delta_compute}, and thus use it
#' as an argument for this function.
#' 
#' It is possible to also provide a high resoultion landmask to this function.
#' For cells which are not included in the original simulation (e.g. because
#' the landmask was discretised at lower resolution), an idw algorightm is used
#' to interpolate the missing values. 
#'
#' @param x a \code{terra::SpatRaster} for the variable of interest, with all
#' time steps of interest
#' @param delta_rast a \code{terra::SpatRaster} generated by 
#' \code{pastclim::delta_compute}
#' @param x_landmask_high a \code{terra::SpatRaster} with the same number of layers
#' as x. If left NULL, the original landmask of x is used.
#' @returns a \code{terra::SpatRaster} of the downscaled variable, where each
#' layers is a time step.
#' @keywords internal


delta_downscale <- function(x, delta_rast,  x_landmask_high=NULL) {
  message("This function is still under development; do not use it for real analysis")
  # check that extent and resolutions are compatible
  if (terra::ext(delta_rast)!=terra::ext(x)){
    stop("x and delta_rast don't have the same extent")
  }
  if (!is.null(x_landmask_high)){
    if (!all((terra::ncol(delta_rast)==terra::ncol(x_landmask_high)),
             (terra::nrow(delta_rast)==terra::nrow(x_landmask_high)))){
      stop("delta_rast and x_landmask_high should have the same number of rows\n",
           "and columns")
    }
  }

  # downscale x with bilinear
  x_high <- disagg(x, fact = terra::res( x)/terra::res(delta_rast),
                   method="bilinear")
  
  # apply the delta_rast to x
  x_high <- x_high + delta_rast
  
  ##TODO
  ## Now loop over each layer of x_high, and run idw_gap to match the high
  ## resolution mask
  
  if(!is.null(x_landmask_high)){
    #refine the landmask in x_high
    #    browser()
    x_high <- mask(x_high,x_landmask_high)
    # fill in any gaps that resulted from this step with idw
    for (i in 1:terra::nlyr(x_high)){
      x_high[[i]] <- idw_interp(x_high[[i]],x_landmask_high[[i]])
    }
  }
  
  return(x_high)
}
